+++
date = "2016-07-03T04:02:20Z"
title = "Manage Channels"
type = "swagger"
description = "Create, update, delete, and archive channels."
keywords= "channels"
weight = "514"
categories = [ "Vendor API" ]
+++
= Vendor API V1


[[_overview]]
= Overview
List, create, update, delete and archive channels.


== Version information
[%hardbreaks]
_Version_ : 1.0.0




[[_paths]]
= Paths

[[_createchannel]]
== Create a channel for an app.
....
POST /app/{app_id}/channel
....


==== Parameters

[options="header", cols=".^1,.^3,.^10,.^4,.^2"]
|===
|Type|Name|Description|Schema|Default
|*Path*|*app_id* +
_required_|App identifier|string|
|*Body*|*Body* +
_required_|JSON input|<<_createchannel_body,Body>>|
|===

[[_createchannel_body]]
*Body*

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*description* +
_optional_||string
|*name* +
_required_||string
|===


==== Responses

[options="header", cols=".^1,.^15,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|CreateChannelResponse contains the JSON channels list|<<_createchannel_response_200,Response 200>>
|*400*|Returned on bad input|No Content
|*401*|Return if the caller is not authorized|No Content
|*403*|Returned if the caller does not have the needed permission|No Content
|*404*|Returned on resource not found|No Content
|===

[[_createchannel_response_200]]
*Response 200*

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*AppChannel* +
_optional_||< <<_appchannel,AppChannel>> > array
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* channel


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*Unknown*|*<<_api_key,api_key>>*|
|===


[[_updatechannel]]
== Update a channel for an app.
....
POST /app/{app_id}/channel/{channel_id}
....


==== Parameters

[options="header", cols=".^1,.^3,.^10,.^4,.^2"]
|===
|Type|Name|Description|Schema|Default
|*Path*|*app_id* +
_required_|App identifier|string|
|*Path*|*channel_id* +
_required_|Channel identifier|string|
|*Body*|*Body* +
_required_|JSON input|<<_updatechannel_body,Body>>|
|===

[[_updatechannel_body]]
*Body*

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*description* +
_optional_||string
|*name* +
_required_||string
|===


==== Responses

[options="header", cols=".^1,.^15,.^4"]
|===
|HTTP Code|Description|Schema
|*204*|On success, no payload returned|No Content
|*400*|Returned on bad input|No Content
|*401*|Return if the caller is not authorized|No Content
|*403*|Returned if the caller does not have the needed permission|No Content
|*404*|Returned on resource not found|No Content
|===


==== Consumes

* `application/json`


==== Produces

* `application/json`


==== Tags

* channel


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*Unknown*|*<<_api_key,api_key>>*|
|===


[[_archivechannel]]
== Archive a channel for an app.
....
POST /app/{app_id}/channel/{channel_id}/archive
....


==== Parameters

[options="header", cols=".^1,.^3,.^10,.^4,.^2"]
|===
|Type|Name|Description|Schema|Default
|*Path*|*app_id* +
_required_|App identifier|string|
|*Path*|*channel_id* +
_required_|Channel identifier|string|
|===


==== Responses

[options="header", cols=".^1,.^15,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|On success|No Content
|*400*|Returned on bad input|No Content
|*401*|Return if the caller is not authorized|No Content
|*403*|Returned if the caller does not have the needed permission|No Content
|*404*|Returned on resource not found|No Content
|===


==== Tags

* channel


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*Unknown*|*<<_api_key,api_key>>*|
|===


[[_updatechannelreleases]]
== Update an existing release.
....
POST /app/{app_id}/channel/{channel_id}/release/{sequence}
....


==== Parameters

[options="header", cols=".^1,.^3,.^10,.^4,.^2"]
|===
|Type|Name|Description|Schema|Default
|*Path*|*app_id* +
_required_|App identifier|string|
|*Path*|*channel_id* +
_required_|Channel identifier|string|
|*Path*|*sequence* +
_required_|Release identifier|integer(int64)|
|*Body*|*Body* +
_required_|JSON payload|<<_updatechannelreleases_body,Body>>|
|===

[[_updatechannelreleases_body]]
*Body*

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*release_notes* +
_required_||string
|*required* +
_required_||boolean
|*version* +
_required_||string
|===


==== Responses

[options="header", cols=".^1,.^15,.^4"]
|===
|HTTP Code|Description|Schema
|*204*|On success, no payload returned|No Content
|*400*|Returned on bad input|No Content
|*401*|Return if the caller is not authorized|No Content
|*403*|Returned if the caller does not have the needed permission|No Content
|*404*|Returned on resource not found|No Content
|===


==== Consumes

* `application/json`


==== Tags

* channel
* release


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*Unknown*|*<<_api_key,api_key>>*|
|===


[[_listchannelreleases]]
== List the releases for an app channel.
....
GET /app/{app_id}/channel/{channel_id}/releases
....


==== Parameters

[options="header", cols=".^1,.^3,.^10,.^4,.^2"]
|===
|Type|Name|Description|Schema|Default
|*Path*|*app_id* +
_required_|App identifier|string|
|*Path*|*channel_id* +
_required_|Channel identifier|string|
|===


==== Responses

[options="header", cols=".^1,.^15,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|ListChannelReleasesResponse lists the channel releases|<<_listchannelreleases_response_200,Response 200>>
|*400*|Returned on bad input|No Content
|*401*|Return if the caller is not authorized|No Content
|*403*|Returned if the caller does not have the needed permission|No Content
|*404*|Returned on resource not found|No Content
|===

[[_listchannelreleases_response_200]]
*Response 200*

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*channel* +
_required_||<<_appchannel,AppChannel>>
|*releases* +
_required_||< <<_channelrelease,ChannelRelease>> > array
|===


==== Produces

* `application/json`


==== Tags

* channel
* releases


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*Unknown*|*<<_api_key,api_key>>*|
|===


[[_listchannels]]
== List channels for an app.
....
GET /app/{app_id}/channels
....


==== Parameters

[options="header", cols=".^1,.^3,.^10,.^4,.^2"]
|===
|Type|Name|Description|Schema|Default
|*Path*|*app_id* +
_required_|App identifier|string|
|===


==== Responses

[options="header", cols=".^1,.^15,.^4"]
|===
|HTTP Code|Description|Schema
|*200*|ListChannelsResponse contains the JSON channels list|<<_listchannels_response_200,Response 200>>
|*400*|Returned on bad input|No Content
|*401*|Return if the caller is not authorized|No Content
|*403*|Returned if the caller does not have the needed permission|No Content
|*404*|Returned on resource not found|No Content
|===

[[_listchannels_response_200]]
*Response 200*

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*AppChannels* +
_optional_||< <<_appchannel,AppChannel>> > array
|===


==== Produces

* `application/json`


==== Tags

* app
* channels


==== Security

[options="header", cols=".^3,.^4,.^13"]
|===
|Type|Name|Scopes
|*Unknown*|*<<_api_key,api_key>>*|
|===




[[_definitions]]
= Definitions

[[_appchannel]]
== AppChannel
An app channel belongs to an app. It contains references to the top (current)
release in the channel.


[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*Adoption* +
_optional_|Adoption rate of licenses in the channel|<<_channeladoption,ChannelAdoption>>
|*Description* +
_required_|Description that will be shown during license installation|string
|*Id* +
_required_|The ID of the channel|string
|*LicenseCounts* +
_optional_|License counts to show the types of licenses in this channel|<<_licensecounts,LicenseCounts>>
|*Name* +
_required_|The name of channel|string
|*Position* +
_optional_|The position for which the channel occurs in a list|integer(int64)
|*ReleaseLabel* +
_optional_|The label of the current release sequence|string
|*ReleaseNotes* +
_optional_|Release notes for the current release sequence|string
|*ReleaseSequence* +
_optional_|A reference to the current release sequence|integer(int64)
|===


[[_channeladoption]]
== ChannelAdoption
ChannelAdoption represents the versions that licenses are on in the channel


[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*current_version_count_active* +
_optional_||< string, integer(int64) > map
|*current_version_count_all* +
_optional_||< string, integer(int64) > map
|*other_version_count_active* +
_optional_||< string, integer(int64) > map
|*other_version_count_all* +
_optional_||< string, integer(int64) > map
|*previous_version_count_active* +
_optional_||< string, integer(int64) > map
|*previous_version_count_all* +
_optional_||< string, integer(int64) > map
|===


[[_channelrelease]]
== ChannelRelease

[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*airgap_build_error* +
_optional_||string
|*airgap_build_status* +
_optional_||string
|*channel_id* +
_optional_||string
|*channel_sequence* +
_optional_||integer(int64)
|*created* +
_optional_||<<_time,Time>>
|*release_notes* +
_optional_||string
|*release_sequence* +
_optional_||integer(int64)
|*required* +
_optional_||boolean
|*updated* +
_optional_||<<_time,Time>>
|*version* +
_optional_||string
|===


[[_licensecounts]]
== LicenseCounts
LicenseCounts is a struct to hold license count information


[options="header", cols=".^3,.^11,.^4"]
|===
|Name|Description|Schema
|*active* +
_optional_||< string, integer(int64) > map
|*airgap* +
_optional_||< string, integer(int64) > map
|*inactive* +
_optional_||< string, integer(int64) > map
|*total* +
_optional_||< string, integer(int64) > map
|===


[[_time]]
== Time
Programs using times should typically store and pass them as values,
not pointers. That is, time variables and struct fields should be of
type time.Time, not *time.Time. A Time value can be used by
multiple goroutines simultaneously.

Time instants can be compared using the Before, After, and Equal methods.
The Sub method subtracts two instants, producing a Duration.
The Add method adds a Time and a Duration, producing a Time.

The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
As this time is unlikely to come up in practice, the IsZero method gives
a simple way of detecting a time that has not been initialized explicitly.

Each Time has associated with it a Location, consulted when computing the
presentation form of the time, such as in the Format, Hour, and Year methods.
The methods Local, UTC, and In return a Time with a specific location.
Changing the location in this way changes only the presentation; it does not
change the instant in time being denoted and therefore does not affect the
computations described in earlier paragraphs.

Note that the Go == operator compares not just the time instant but also the
Location. Therefore, Time values should not be used as map or database keys
without first guaranteeing that the identical Location has been set for all
values, which can be achieved through use of the UTC or Local method.

_Type_ : object





